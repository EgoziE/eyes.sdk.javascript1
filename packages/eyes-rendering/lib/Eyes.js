'use strict';

const { makeRenderingGridClient } = require('@applitools/visual-grid-client');
const { getProcessPageAndSerializeScript } = require('@applitools/dom-capture');
const { Logger, ArgumentGuard, TypeUtils, BatchInfo } = require('@applitools/eyes-sdk-core');

class Eyes {
  constructor() {
    /** @type {Logger} */ this._logger = new Logger(true);
    /** @type {String} */ this._serverUrl = undefined;

    /** @type {EyesJsExecutor} */ this._jsExecutor = undefined;
    /** @type {ProxySettings} */ this._proxy = undefined;
    /** @type {BatchInfo} */ this._batchInfo = new BatchInfo();

    this._isOpen = false;
    this._processPageAndSerializeScript = undefined;

    this._checkWindowCommand = undefined;
    this._closeCommand = undefined;
  }

  /**
   * Sets a handler of log messages generated by this API.
   *
   * @param {LogHandler} logHandler Handles log messages generated by this API.
   */
  setLogHandler(logHandler) {
    this._logger = new Logger();
    this._logger.setLogHandler(logHandler);
  }

  /**
   * @param {WebDriver} webDriver
   * @param {RenderingConfiguration} renderingConfiguration
   */
  async open(webDriver, renderingConfiguration) {
    this._logger.verbose('enter');

    ArgumentGuard.notNull(webDriver, 'webDriver');
    ArgumentGuard.notNull(renderingConfiguration, 'renderingConfiguration');

    const apiKey = process.env.APPLITOOLS_API_KEY;
    const showLogs = process.env.APPLITOOLS_SHOW_LOGS;
    const saveDebugData = process.env.APPLITOOLS_SAVE_DEBUG_DATA;

    await this._initDriver(webDriver);

    if (renderingConfiguration.getBatch() == null) {
      renderingConfiguration.setBatch(this._batchInfo);
    }

    const { openEyes } = makeRenderingGridClient({
      showLogs,
      apiKey,
      saveDebugData,
      proxy: this._proxy,
      serverUrl: this._serverUrl,
      renderConcurrencyFactor: renderingConfiguration.getConcurrentSessions(),
    });

    this._processPageAndSerializeScript = await getProcessPageAndSerializeScript();

    this._logger.verbose('opening openEyes...');

    const { checkWindow, close } = await openEyes({
      appName: renderingConfiguration.getAppName(),
      testName: renderingConfiguration.getTestName(),
      browser: renderingConfiguration.getBrowsersInfo(),

      // properties,
      batchName: renderingConfiguration.getBatch().getName(),
      batchId: renderingConfiguration.getBatch().getId(),
      baselineBranchName: renderingConfiguration.getBaselineBranchName(),
      baselineEnvName: renderingConfiguration.getBaselineEnvName(),
      // baselineName,
      envName: renderingConfiguration.getEnvironmentName(),
      // ignoreCaret,
      // isDisabled,
      // matchLevel,
      // matchTimeout,
      parentBranchName: renderingConfiguration.getParentBranchName(),
      branchName: renderingConfiguration.getBranchName(),
      // saveFailedTests,
      // saveNewTests,
      // compareWithParentBranch,
      // ignoreBaseline,
      logger: this._logger,
      // renderBatch,
      // waitForRenderedStatus,
      // renderThroat,
      // getRenderInfoPromise,
      // getHandledRenderInfoPromise,
      // getRenderInfo,
      // createRGridDOMAndGetResourceMapping,
      // eyesTransactionThroat,
      agentId: renderingConfiguration.getAgentId(),
    });

    this._checkWindowCommand = checkWindow;
    this._closeCommand = close;
    this._isOpen = true;
    this._logger.verbose('done');
  }

  /**
   * @private
   * @param {WebDriver} webDriver
   */
  async _initDriver(webDriver) {
    if (TypeUtils.hasMethod(webDriver, ['executeScript', 'executeAsyncScript'])) {
      this._jsExecutor = webDriver;
    }
  }

  /**
   * @param {boolean} [throwException]
   * @return {TestResults}
   */
  async close(throwException) {
    await this.closeAndReturnResults();
    return null;
  }

  /**
   * @return {TestResults}
   */
  abortIfNotClosed() {
    return null; // TODO - implement?
  }

  /**
   * @return {boolean}
   */
  getIsOpen() {
    return this._isOpen;
  }

  /**
   * @return {boolean}
   */
  getIsDisabled() {
    return false;
  }

  /**
   * @param {boolean} [throwEx]
   * @return {Promise<TestResults[]>}
   */
  async closeAndReturnResults(throwEx = true) {
    const results = await this._closeCommand(throwEx);

    this._isOpen = false;

    return results;
  }

  /**
   * @param {boolean} [throwEx]
   * @return {Promise<*>}
   */
  async closeAndPrintResults(throwEx = true) {
    const results = await this.closeAndReturnResults(throwEx);

    if (results.length > 0) {
      console.log('\n[EYES: TEST RESULTS]:');
      results.forEach(result => {
        const testTitle = `${result.getName()} [${result.getHostDisplaySize().toString()}] - `;

        if (result.getIsNew()) {
          console.log(testTitle, 'New');
        } else if (result.isPassed()) {
          console.log(testTitle, 'Passed');
        } else {
          const stepsFailed = result.getMismatches() + result.getMissing();
          console.log(testTitle, `Failed ${stepsFailed} of ${result.getSteps()}`);
        }
      });
      console.log('See details at', results[0].getAppUrls().getBatch());
    } else {
      console.log('Test is finished but no results returned.');
    }
  }

  /**
   * @param {BatchInfo} batchInfo
   */
  setBatch(batchInfo) {
    this._batchInfo = batchInfo;
  }

  /**
   * @param {String} serverUrl
   */
  setServerUrl(serverUrl) {
    this._serverUrl = serverUrl;
  }

  /**
   * Sets the proxy settings to be used by the rest client.
   * @param {ProxySettings} proxySettings The proxy settings to be used by the rest client. If {@code null} then no proxy is set.
   */
  setProxy(proxySettings) {
    this._proxy = proxySettings;
  }

  /**
   * @param {String} name
   * @param {CheckRGSettings} checkSettings
   */
  async check(name, checkSettings) {
    ArgumentGuard.notNull(checkSettings, 'checkSettings');

    if (TypeUtils.isNotNull(name)) {
      checkSettings.withName(name);
    }

    this._logger.verbose(` $$$$$$$$$$    Dom extraction starting   (${checkSettings.toString()})   $$$$$$$$$$$$`);

    const domCaptureScript = `var callback = arguments[arguments.length - 1]; return (${this._processPageAndSerializeScript})().then(JSON.stringify).then(callback, function(err) {callback(err.stack || err.toString())})`;
    const results = await this._jsExecutor.executeAsyncScript(domCaptureScript);
    const { cdt, url: pageUrl, blobs, resourceUrls } = JSON.parse(results);

    const resourceContents = blobs.map(({ url, type, value }) => ({
      url,
      type,
      value: Buffer.from(value, 'base64'),
    }));

    this._logger.verbose(` $$$$$$$$$$    Dom extracted  (${checkSettings.toString()})   $$$$$$$$$$$$`);

    await this._checkWindowCommand({
      resourceUrls,
      resourceContents,
      cdt,
      url: pageUrl,
      tag: checkSettings.getName(),
      region: checkSettings.getRegion(),
      selector: checkSettings.getSelector(),
      scriptHooks: checkSettings.getScriptHooks(),
      sizeMode: checkSettings.getSizeMode(),
      sendDom: checkSettings.getSendDom(),
    });
  }
}

exports.Eyes = Eyes;
